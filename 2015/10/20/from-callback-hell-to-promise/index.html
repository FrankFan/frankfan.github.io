<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 从快的线上callback hell代码说起 · Frank Fan's Blog</title><meta name="description" content="从快的线上callback hell代码说起 - Frank Fan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://fy98.com/atom.xml" title="Frank Fan's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">从快的线上callback hell代码说起</h1><div class="post-info">2015年10月20日</div><div class="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>就像谈到闭包必须要说js变量作用域一样，谈到 promise 之前肯定要先说谈异步编程。一直以来， javascript 处理异步方式都是使用 callback 方式，对与写 javascript 的人来时候 callback 深入人心。比如只有前端经验没有后端经验的同学看到 java 代码可能会问『为什么readFile方法可以直接返回结果？为何不使用 callback 』</p>
<p>由于 javascript 的单线程性质，必须等待上一个事件执行完成才能处理下一步。传统解决 javascript 异步编程的方法就是使用 callback，比如这样：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fsc1axbripj30ar051t94.jpg" alt=""></p>
<p>再比如这样：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fsbzmykdtgj31750i8wgg.jpg" alt=""></p>
<p>截止到2015年10月20日晚还可以访问:<br><a href="http://www.kuaidadi.com/assets/js/animate.js" target="_blank" rel="noopener">http://www.kuaidadi.com/assets/js/animate.js</a></p>
<p>『快的』用线上代码为我们生动的演示了什么叫<code>callback hell</code>——『回调地狱』。</p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise 字面上可以理解为『承诺』，即A调用B，B返回一个『承诺』给A，然后A就可以认为B给我返回结果的时候我就执行方案一了，反之没有得到结果就执行方案二。</p>
<p>上面这句话翻译为代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resB = B();</span><br><span class="line"><span class="keyword">var</span> runA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resB.then(execPlan1, execPlan2);</span><br><span class="line">&#125;</span><br><span class="line">runA();</span><br></pre></td></tr></table></figure>
<p>Promise 是一种异步操作模式，表示一个异步操作的最终结果，返回的是一个 Promise 对象，由于是立即返回，所以可以采用同步操作的流程。 这个 Promise 对象有一个 then 方法，允许指定回调函数，在异步任务完成后调用。</p>
<p>比如上面『快的』的例子可以改写为这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Promise</span>(step1))</span><br><span class="line">    .then(step2)</span><br><span class="line">    .then(step3)</span><br><span class="line">    .then(step4)</span><br><span class="line">    .then(step5)</span><br><span class="line">    .then(step6)</span><br><span class="line">    .then(step7)</span><br><span class="line">    .then(step8)</span><br><span class="line">    .then(step9)</span><br><span class="line">    .then(step10)</span><br><span class="line">    .then(step11)</span><br><span class="line">    .then(step12)</span><br><span class="line">    .then(step13)</span><br><span class="line">    .then(step14)</span><br><span class="line">    .then(step15)</span><br><span class="line">    .then(step16)</span><br><span class="line">    .then(step17);</span><br></pre></td></tr></table></figure>
<p>看，『横向的胖子』变的苗条了，看起来是不是更加可爱呢？</p>
<p>Promise有个一个规范叫做 <a href="https://github.com/promises-aplus/promises-spec" target="_blank" rel="noopener">Promises/A+</a>,  有各种各样的第三方库遵循这个规范实现了 Promise/A+ 。 比如 <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">Q</a>、 <a href="https://github.com/cujojs/when" target="_blank" rel="noopener">when</a>, jQuery 有个类似的方法叫 <a href="http://api.jquery.com/category/deferred-object/" target="_blank" rel="noopener">Deferred。</a></p>
<p>一个 Promise 对象的实例一般有三种状态：未完成（pending）、已完成（fulfilled）和失败（rejected）。</p>
<blockquote>
<p>这三种的状态的变化途径只有两个，且只能发生一次：从“未完成”到“已完成”，或者从“未完成”到“失败”。<br>一旦当前状态变为“已完成”或“失败”，就意味着不会再发生状态变化了。</p>
</blockquote>
<p>Promise对象的运行结果，最终只有两种。</p>
<blockquote>
<p>得到一个值，状态变为fulfilled<br>抛出一个错误，状态变为rejected</p>
</blockquote>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ol>
<li><a href="http://www.alloyteam.com/2014/05/javascript-promise-mode/" target="_blank" rel="noopener">JavaScript Promise启示录</a></li>
<li><a href="http://liubin.github.io/promises-book/" target="_blank" rel="noopener">JavaScript Promise迷你书（中文版）</a></li>
<li><a href="http://www.html5rocks.com/zh/tutorials/es6/promises/" target="_blank" rel="noopener">JavaScript Promises</a></li>
<li><a href="http://javascript.ruanyifeng.com/advanced/promise.html" target="_blank" rel="noopener">javascript.ruanyifeng.com</a></li>
<li><a href="http://segmentfault.com/a/1190000002452115" target="_blank" rel="noopener">Promise/A+规范</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2015/10/31/remember-git-push-300-days-continuously/" class="prev">PREV</a><a href="/2015/10/15/gitlab-tree-chrome-extentsion/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2018 <a href="http://fy98.com">Frank Fan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>