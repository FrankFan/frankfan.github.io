<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> js作用域和闭包 · Frank Fan's Blog</title><meta name="description" content="js作用域和闭包 - Frank Fan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://fy98.com/atom.xml" title="Frank Fan's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">js作用域和闭包</h1><div class="post-info">2015年1月15日</div><div class="post-content"><h2 id="Javascript作用域概要"><a href="#Javascript作用域概要" class="headerlink" title="Javascript作用域概要"></a>Javascript作用域概要</h2><p>在Javascript中，作用域是执行代码的上下文。作用域有三种类型，<code>全局作用域</code>、<code>局部作用域</code>（有时也称作“函数作用域”）和<code>eval作用域</code>。</p>
<p>在函数内部使用<code>var</code>关键字定义变量，其作用域是局部的，且只对该函数的其他表达式是“可见的”，包括嵌套/子函数中的代码。在全局作用域内定义的变量从任何地方都可以访问，因为它是作用域链中的最高层/最后一个。</p>
<p>如下代码演示由于受作用域的影响，<code>foo</code>的每个生命都是独一无二的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">0</span>; <span class="comment">// global scope</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// output 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> foo = <span class="number">1</span>; <span class="comment">// local scope</span></span><br><span class="line">	<span class="built_in">console</span>.log(foo); <span class="comment">// output 1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> myNestedFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> foo = <span class="number">2</span>; <span class="comment">// local scope</span></span><br><span class="line">		<span class="built_in">console</span>.log(foo); <span class="comment">// output 2</span></span><br><span class="line">	&#125;();</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'var foo = 3; console.log(foo);'</span>); <span class="comment">// eval 作用域 output 3</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<ul>
<li>可以创建无数的函数作用域和eval作用域，而Javascript环境只使用一个全局作用域。</li>
<li>全局作用域是作用域链中的最后一层。</li>
<li>包含函数的函数，会创建堆栈执行作用域，这些链接在一起的栈通常被称为<code>作用域链</code>。</li>
</ul>
</blockquote>
<h2 id="Javascript没有块级作用域"><a href="#Javascript没有块级作用域" class="headerlink" title="Javascript没有块级作用域"></a>Javascript没有块级作用域</h2><p>由于逻辑语句（如if(){}）和循环语句（如for）无法创建作用域，因此变量可以互相覆盖。查看如下代码，并了解foo值被重新定义为执行代码的程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	foo = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">3</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">		foo = i;  <span class="comment">// foo 等于3、4，然后等于5</span></span><br><span class="line">		<span class="built_in">console</span>.log(foo); <span class="comment">// output 3, 4, 5</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，代码执行时foo是变化的，因为Javascript根本没有块级作用域，只有函数、全局和eval作用域。</p>
<h2 id="在函数中用var声明变量，避免作用域陷阱"><a href="#在函数中用var声明变量，避免作用域陷阱" class="headerlink" title="在函数中用var声明变量，避免作用域陷阱"></a>在函数中用var声明变量，避免作用域陷阱</h2><p>Javascript会将缺少var的变量声明（即便是在函数或者封装的函数中）声明在全局作用域中，而非局部作用域。查看如下代码，请注意，如果不使用var来声明bar，那么该变量实际上是在全局作用域中定义，而不是在局部作用域中定义（其实本应该在局部作用域中定义）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> boo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		bar = <span class="number">2</span>; <span class="comment">// 没有使用var，所以var是在全局作用域中，即 window.bar</span></span><br><span class="line">	&#125;();</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// output 2 因为bar在全局作用域中</span></span><br></pre></td></tr></table></figure>
<p>相反：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> boo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> doo = <span class="number">2</span>; <span class="comment">// 使用var，所以var是在局部作用域</span></span><br><span class="line">	&#125;();</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doo); <span class="comment">// 报错，Uncaught ReferenceError: doo is not defined</span></span><br></pre></td></tr></table></figure>
<p>这里的重点是，在函数内部定义变量时，应该使用var，这样我们不用于处理那些潜在的易混淆的作用域问题。当然，要在函数内部创建或更改全局作用域内的属性，属于本规则的例外情况。</p>
<h2 id="作用域链——chain-scope（词法作用域）"><a href="#作用域链——chain-scope（词法作用域）" class="headerlink" title="作用域链——chain scope（词法作用域）"></a>作用域链——chain scope（词法作用域）</h2><p>当Javascript查找与变量相关的值时，会遵循一个查找链。这个链是基于作用域的层次结构的。在如下代码中，从func2函数作用域中记录了<code>sayHiText</code>值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHiText = <span class="string">'hi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(sayHiText); <span class="comment">// hi</span></span><br><span class="line">	&#125;();</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>当sayHiText值不包含在func2函数的作用域内部时，如何找到它? Javascript首先在func2函数中查找一个名为sayHiText的变量。如果在func2函数中没有找打，就会查找func2的父函数——func1。 在func1作用域中也找不到sayHiText变量，因此，Javascript会继续查找全局作用域（此处可找到sayHiText值）。如果sayHiText没有在全局作用域内定义，那么Javascript就会返回<code>undefined</code>。</p>
<p>这是一个需要掌握的非常重要的概念。让我们来看另一个代码示例。如下代码，从三个不同的作用域获取三个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> z = <span class="number">30</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(z + y + x); <span class="comment">// output 60 不解释了</span></span><br><span class="line">	&#125;();</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<ul>
<li>仔细想一下，其实作用域链与原型链的区别并不大。两者都是通过位置体系和层次体系来查找值的方法。</li>
</ul>
</blockquote>
<h2 id="作用域链查找返回第一轮值"><a href="#作用域链查找返回第一轮值" class="headerlink" title="作用域链查找返回第一轮值"></a>作用域链查找返回第一轮值</h2><p>看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="literal">false</span>;</span><br><span class="line">	bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> x = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(x); <span class="comment">// 局部x在作用域内是第一个被查找到的，因此不再查找其余的</span></span><br><span class="line">	&#125;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// output false</span></span><br></pre></td></tr></table></figure>
<p>请记住，当在作用域链内最近位置找到变量时，查找即结束，不管作用域链顶部是否还有相同的变量名称。其实就是<code>就近原则</code>。</p>
<h2 id="函数定义时确定作用域，而非调用时确定"><a href="#函数定义时确定作用域，而非调用时确定" class="headerlink" title="函数定义时确定作用域，而非调用时确定"></a>函数定义时确定作用域，而非调用时确定</h2><p>由于函数决定作用域，并且函数可以像任何Javascript值那样被传递，因此有人可能会认为解密作用域链是很复杂的。它实际上却是非常简单的。作用域链是根据函数定义时的位置确定，而不是在调用时确定的。这也叫<code>词法作用域</code>。仔细思考这个问题，因为大多数人在编写Javascript代码时会被它绊住。</p>
<p>作用域链是在调用函数之前创建。正因为如此，我们可以创建闭包。例如，我们而已让函数向全局作用域返回一个嵌套函数，但该函数仍然能够通过作用域链访问其父函数的作用域。</p>
<p>如下代码，定义了parentFunction，它返回一个匿名函数，从全局作用域调用返回的函数。因为匿名函数被定义为包含在parentFunction内部，因此，它被调用后仍然能够访问parentFunction的作用域。<br><code>这就是闭包</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parentFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(foo);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nestedFunction引用parentFunction函数返回的匿名函数</span></span><br><span class="line"><span class="keyword">var</span> nestedFunction = parentFunction();</span><br><span class="line"></span><br><span class="line">nestedFunction(); <span class="comment">// 输出 foo, 因为返回的函数可以通过作用域链访问foo</span></span><br></pre></td></tr></table></figure>
<p>这里应该理解的重点是，作用域连是在定义时确定的——实际是编码的方式。在函数内部传递代码不会改变作用域链。</p>
<h2 id="闭包closures是由作用域链引起的"><a href="#闭包closures是由作用域链引起的" class="headerlink" title="闭包closures是由作用域链引起的"></a>闭包<code>closures</code>是由作用域链引起的</h2><p>有了作用域和作用域链的知识，就不难理解闭包了。如下代码，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countUpFromZero = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 调用countUpFromZero的时候返回的嵌套子函数</span></span><br><span class="line">		<span class="keyword">return</span> ++count; <span class="comment">// count 在作用域链内定义，父函数里</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;(); <span class="comment">// 立即调用，返回嵌套函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(countUpFromZero()); <span class="comment">// output 1</span></span><br><span class="line"><span class="built_in">console</span>.log(countUpFromZero()); <span class="comment">// output 2</span></span><br><span class="line"><span class="built_in">console</span>.log(countUpFromZero()); <span class="comment">// output 3</span></span><br></pre></td></tr></table></figure>
<p>每次调用<code>countUpFromZero</code>函数时，包含在countUpFromZero函数内（并由其返回的）的匿名函数仍可以访问父函数的作用域。这种技术，通过使用作用域链，就是一个闭包的示例。</p>
<p>总结一下，闭包就是<code>闭包就是能够从外部读取内部函数的内部变量的函数。</code>（反过来是很正常的）。<br>在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h2 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h2><blockquote>
<ol>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ol>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2015/01/20/function-first-class-citizen-in-javascript/" class="prev">PREV</a><a href="/2015/01/11/git-integrated-with-beyond-compare-in-windows/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2018 <a href="http://fy98.com">Frank Fan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>